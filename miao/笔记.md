#大喵培训笔记

4/29
    css 最少200行  js最少100行
	marjin heverbeke  a modern intro to programming
	
	操作
	    shift+右键
	win
	    path
	快捷键
	    hoekey   autohotkey
	软件
	    everything 
		strokeit
	
	chrome.exe --proxy-pac-url=https://cddm.me/ac.js
--------------------------------------------------
4/30
    对数   三角函数  线性/非线性  
	内核   webkit   gecko
	聊聊折腾的重要性
	www.canluse.com
	
	8bit=1byte  24bit=3个字节(byte) 每一bit 可以代表0 或 1 的数位讯号
	
	照片
	    jpg-jpeg
		    有损压缩
		png
		    无损压缩
			支持透明色
		gif
		    无损（原始图片颜色数量不足256色）
			抽烟出256种颜色
			支持透明，只有两种，一种完全不透明，要么完全透明
		bmp
		    无压缩
			每个点3个字节  (取决于 24/位   单色/1bit  256色/8bit)
		webp
		    google发明
			有损压缩
			各方面都胜过jpg适合移动端使用
			支持alpha通道
	
	ASCII
	    0=48  1=49   10和13  A=65   a=97  空格=
	Unicode
	    编号
		UFT-8编码方式
	GUI   图形化  用户界面接口
	CLI    命令行
	    GUI和CLI不同在于形式不一样
	API   应用编程接口
	技能树
	
	linux
	    cgywin
		mingw 
		wsl windos subsy for linux
	命令行
	    当前工作目录    
		裸命令
		    pwd显示出当前目录的绝对路径
		    ls  当前目录的列表   ls --all  全部的文件
			   ls -l长列表输出形式
			   ls -lah  所有文件长列表形式
	        touch   创建文档
		    cd  change dir  切换路径
			print
			clear
			working
			diretory
			cd /home 进入 '/ home' 目录' 
			cd .. 返回上一级目录 
			cd ../.. 返回上两级目录 
			cd 进入个人的主目录 
			cd ~user1 进入个人的主目录 
			cd - 返回上次所在的目录 
			pwd 显示工作路径 
			ls 查看目录中的文件 
			ls -F 查看目录中的文件 
			ls -l 显示文件和目录的详细资料 
			ls -a 显示隐藏文件 
			ls *[0-9]* 显示包含数字的文件名和目录名 
			tree 显示文件和目录由根目录开始的树形结构(1) 
			lstree 显示文件和目录由根目录开始的树形结构(2) 
			mkdir dir1 创建一个叫做 'dir1' 的目录' 
			mkdir dir1 dir2 同时创建两个目录 
			mkdir -p /tmp/dir1/dir2 创建一个目录树 
			rm -f file1 删除一个叫做 'file1' 的文件' 
			rmdir dir1 删除一个叫做 'dir1' 的目录' 
			rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 
			rm -rf dir1 dir2 同时删除两个目录及它们的内容 
			mv dir1 new_dir 重命名/移动 一个目录 
			cp file1 file2 复制一个文件 
			cp dir/* . 复制一个目录下的所有文件到当前工作目录 
			cp -a /tmp/dir1 . 复制一个目录到当前工作目录 
			cp -a dir1 dir2 复制一个目录 
			ln -s file1 lnk1 创建一个指向文件或目录的软链接 
			ln file1 lnk1 创建一个指向文件或目录的物理链接 
			touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) 
			file file1 outputs the mime type of the file as text 
			iconv -l 列出已知的编码 
			iconv -f fromEncoding -t toEncoding inputFile > outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. 
			find . -maxdepth 1 -name *.jpg -print -exec convert "{}" -resize 80x60 "thumbs/{}" \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 

			文件搜索 
			find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录 
			find / -user user1 搜索属于用户 'user1' 的文件和目录 
			find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 
			find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 
			find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 
			find / -name \*.rpm -exec chmod 755 '{}' \; 搜索以 '.rpm' 结尾的文件并定义其权限 
			find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备 
			locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 
			whereis halt 显示一个二进制文件、源码或man的位置 
			which halt 显示一个二进制文件或可执行文件的完整路径 
	
		带参数
		    ls --help 命令帮助
		管道  |
		PM2 -h 
		
		ctrl+c  结束
		
        路径    which+命令
    命令格式
	    命令名+参数
		在windows的wsl中也可以，安装好wsl后执行以下命令：
		sudo apt install fortune
		sudo apt install cowsay
		sudo apt install lolcat
		后也可以
--------------------------------------------------
5/1
    BOM
	命令
	    cat 查看文件内容
		echo  打印东西  命令行脚本文件
		cd  相对路径 
		
		sudo  super user do
		rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 
		rm -rf dir1 dir2 同时删除两个目录及它们的内容 
		rmdir   删除空文件
		rm   只能删文件，不能删文件夹
		mkdir dir1 创建一个叫做 'dir1' 的目录
		mkdir -p /tmp/dir1/dir2 创建一个目录树 
		mv  移动(重命令)
		cal 日历  cal --help
		cmt
		mc  图形界面
		apt update
		vi  编辑器  查看模式   I 编辑模式 ：w  保存  ：wq  保存并退出
		vimtutor  教程
		nano
		mc  mcedit
--------------------------------------------------
#5/2
	markdown语法
	*有序
	**粗体
	``代码  4个空格
	```css  有高亮  不用空格
	
	sublime命令窗口  ctrl+s+p 
		ctrl+p

	## 多行快捷键
		ctrl+D  多选
		ctrl+s+l  
		

	##HTML
	自闭和标签
	a标签
		<a href="#">特定位置
	p tag    develop
	alt   替补选项  
	input  表单元素用name
	alternative  可选项
	alternate
	alter 修改
	source
	class属性
	comma separatad list
	tabindex  可以控制tab建的  用在可交互元素
	data-   杜撰的属性加
	转义符
	&；  &=amp
	&nbsp  160号空格
	html ent（实体）w3
	
	csszzengarden
--------------------------------------------------
	
#5/3
	head
		页面编码方式   charset
		页面图标  link   rel属性  /favicon，ico
		base   基准  href   target属性 _blank  新窗口  _self  不是新窗口
		meta   refresh刷新  
				http-equiv=“refresh”  content=“1”				bash
					先用git bash打开
					browser-sync start --server --directory --files "*"
					保存后刷新
	1.git add .
	2.git commit -m ""
	git remote  添加远程仓库路径
	git push
	git pull 合并
	git status   状态
	git diff    版本之间的差异
	git checkout master  回到之前版本
	
	git log  提交日志  (https://github.com/robin191/learn-git)
	git clone  克隆仓库
	

##5/6
	
	pre  内容的空格和回车都都会保留
			可以和<code>一起用
	obs
	
	marquee   已经不再用  滚动 
	em  语义为强调，为斜体
	
	可访问性 accessibility   a11y  internationalizition  i18n
              * 读屏软件
              * windows 高比对度主题
              * a r i a/role
			  * accessibly rich internet application
			  * 网页应用程序
			  * role属性提示浏览器当前元素是一个何种视觉元素 比如菜单  导航条 内容等
			  * aria-xxx=yyy提示浏览器当前视觉元素的状态或其他信息
	
	form
		input
			type属性
				text
				password
				checkbox  多选
				radio  单选
			* file
                - accept
                + 可以接受的文件类型
                + `<input type="file" name="" id="" accept="image/*,text/*">`
               * MIME Type
                + `<input type="file" name="" id="" accept=".jpg,.png,.gif,.jpeg,.webp,.exe" 					value="c:/user/xieran/desktop/a.pdf">`
                * http://wwww.a.com/favicon.ico
                - 安全问题
                - multiple
                    + 是否支持多选文件
                    * hidden
                        - 隐藏的输入域
                        - value设置其值
                        - name设置名字
                    * 为以下三个值时，都表现为按钮的样式，按钮上的文字需要用value属性来设置
                    * image
                        - 此时需要使用src属性指定图片的地址
                        - 现在基本上不这么用，之所以有这个用法，是以前不用js时想做出漂亮的按钮时，								需要这么用
                        - 在html5中，可以在这种标签上给定width跟height，类似img标签相应的属性，src，alt
			 disabled
                     + 无值的属性
                 	 + 禁用这个输入域	
		    required
                   + 设置这个输入域为必填项
                   + 不填的话无法用**正常手段**触发表单提交
			placeholder
                    + 占位符
                    + 提示性文字，一旦输入内容就消失
			autofocus
                            + 自动获得焦点，即页面加载完                 后光标自动在这个元素内

	button
		type
			* 不写type属性的话，默认为submit
                - 即：无type的button的type		属性默认为submit
                * `<button type="reset/button/submit">Submit</button>
			* button
                - 常规按钮，功能上与input[type="button"]一样
                * submit
                - 提交按钮，功能上与input[type="submit"]一样
                * reset
                - 重置按钮，功能上与input[type="reset"]一样
			与`<input type="button" name="b" value="lksjdf">`的区别
                * input的button只能在按钮上显示纯文字
                * 而button标签可以在按钮上显示其它内容比如图片（即嵌套其它标签），文字也可以设置不同颜色等	
			label 标签
                    + 一般与checkbox及radio一起用，以扩大这两个按钮的可点击区域，提升用户体验。当然，也可以跟其它元素一起用，不过一般没必要（比较典型的是与input:file一起用）
                    - for属性
                        + 为 想要被扩大点击区域的元素的id，不带井号
                        - 支持度非常好，ie5都支持
                        - 细节：在ie8及以下不能用于displaynone的表单元素，可能是因为 not focusable
                        - 表单元素嵌套在label的时候可以不用for属性
                          ```html
                          <form action="">
                            有for的用法
                            <label for="oneid">One</label>

                            <input onclick type="text" id="oneid">

                            不用for的用法
                            <label>
                              <input type="checkbox"> 男
                            </label>
                          </form>
                          ```
                    - 如下怎么算呢？
                      ```html
                      <input id="a">
                      <label for="a">
                        <input type="text">
                      </label>
                      ```

                    - 典型的坑，两次点击，等学了js后再谈
                - select name="sel"
                    + 下拉选择框
                    + 属性
                        * multiple
                            - 无值属性，表示多选，多选时就不是下拉的样式了
                    + 另外此标签在不同的系统里面样式差别很大，而且它的样式一般来说是取自系统自带的，所以很难被css控制
                        * 所以一些对ui要求比较高的网站都选择用其它元素模拟下拉框
                            - 例：小米路由器
                * option
                    * value
                        - 选择了该项目后它所属的select元素的值
                    * selected
                        - 默认被选中
                    * disabled
                        - 表示该项被禁用
                    * hidden
                        - 表示该项被隐藏
                    - 以上三个属性均无值
                * optgroup // hgroup  colgroup
                    - 给option分组
                    - 用label属性表示这个分组的名字
                    - 无法被选中，只能选择option
                    - 有一个disabled属性，如果设置了这个属性，整组标签都会被禁用
                    ```html
                    <select>
                        <option value="1">1</option>
                        <optgroup label="这是一个分组" disabled hidden>
                            <option value="01">01</option>
                            <option value="02">02</option>
                            <option value="03">03</option>
                            <option value="04">04</option>
                            <option value="05">05</option>
                        </optgroup>
                    </select>
                    ```
                    - 兼容性不确定，因为我没用过mac。。。。
                - textarea
                    + 多行文本输入框
                    + 两个特殊属性
                        * rows="3"
                        * cols="20"
                    + 不过现在也不常用，一般都用css来控制了
                - field set 字段组 用来把 一组 输入域 放在一起的。
                    + field就是字段的意思，就是说一个表单输入域（输入框）
                    + 这个标签用来给输入域分组，所以叫set
                        * set本来就是组的意思
                    + 如果只是分组，完全可以用div等标签
                        * 那这个标签有什么用呢？
                        * fieldset有个disabled属性，如果它有了这个属性，其内的所有输入域都将被禁							用，类似optgroup
                            - 在某些场景下是非常好用的
                - legend
                    + 只能作为 fieldset 的子元素，用来标识这组输入域的名字，基本上没有其它用处
                        * 而且在有了css之后，这个标签基本也没有用武之地了

			
	MIME Type 媒体类型
	jpg  image/jpg
	png  image/png
	gif  image/gif
	
	html  text/html
	css   text/css
	js    application/javascript
	
	multpile 多选
	
	selected  不被选择
--------------------------------------------------
		
##5/7
	table
		这个标签以前经常用于做布局
        + 什么是布局？即页面大区块的排列和摆放
        + 为什么呢？因为table都是方方正正格子，了解后很容易控制
            * 语义很差
            * 可读性很差
            * 可维护性也很差 maintainable
            * 可访问性
        + 但现在有了 css 之后，基本上只用table来显示数据，即表格本来的作用
        + 熟悉 DIV+CSS 布局 JD Job Description
    * caption
        - 表格标题
    * thead
        - 表头
        - 做为table的直接子元素
        - 只能有一个
        - 只有一个的情况下，即使出现在tbody的后面，其内容也会显示在tbody的前面
        - 非要写多个的话，第一个以外的会当做tbody来处理
    * tbody
        - 表格主体
        - 做为table的直接子元素
        - 可以有多个
    * tfoot
        - 表尾
        - 做为table的直接子元素
        - 只能有一个
        - 只有一个的情况即使出现在tbody的前面面，它的行也出现在tbody的后面
        - 非要写多个的话，第一个以外的会当做tbody来处理
    * tr
        - table row cell
        - 表格行
        - 可以直接做为table的子元素，会被放入创建的tbody里面
        - 或者做为上面三个标签(thead/tbody/tfoot)的子元素
    * th
        - table header cell
        - 用在表头单元格
        - 文字默认为加粗
        - id用于被td元素引用以表示td所属的标题是哪一个
            + 看例子
    * td
        - table data，表格数据单元格
        - headers
            + 表格头，值为某th的id，以表示这个数据的名称
                * 方便读屏软件
            + headers的值可以是多个以空格分隔的th的id的值，用法可能是th或td单元格跨行或跨列了
		col 列   
		colgroup  <colgroup bgcolor=>
					<col
					<col
					<col bgcolor>
				  <colgroup bgcolor=>
		colspan  跨行
		rowspan  跨列
		
		
		* map
    - 不是“地图”标签，是“映射”标签
    - name属性
    - 如果设置id属性的话，id跟name属性值必须一样
        * <input type="radio" name="a" id="a1">
          <input type="radio" name="a" id="a2">
          <input type="radio" name="a" id="a3">
          <input type="radio" name="a" id="a4">
          <input type="radio" name="a" id="a5">
    * area
    - 必须做为map的子元素
    - w3school上的错误示范：http://www.w3school.com.cn/tags/att_img_usemap.asp
    - 属性
        + href
        + target
        + alt
        + 以上三个属性同a标签
        + shape
            * rect(angle)，矩形
                - x1,y1,x2,y2
            * circle，圆形
                - cx,cy,r
                - 圆心x，圆心y
                - 半径r
            * poly(gon)，多边形
                - 至少6个值，表示一个多边形的若干个顶点
        + coords coordinate
            * 对应shape的几种图形的坐标
        + code
          ```html
          <img title="image title" src="https://drscdn.500px.org/photo/174778125/m%3D1170_k%3D1/2841ccf2a3720e8e794a6a6930f6ff2c" width=300 usemap="#somemap" alt="">
          
          <map name="somemap">
            <area shape="rect" coords="55,108,205,200" href="https://www.mi.com/" alt="ieksoef" title="abc" target="_blank">
            <area shape="circle" coords="133,262,90" href="" alt="">
            <area shape="poly" coords="57,82,8,265,163,397,225,256,187,83" href="" alt="">
          </map>
	
	* iframe
    - inline frame
    - 必须有开始标签和结束标签
        + 可以在标签之间写上不支持此标签时的退化内容
    * 各种属性
        - src
        - name
            + 提及a标签的target属性
              * _self, _blank
              * _top, _parent
              * 自定义名字
            * 以前常用来做导航
            * base, a, form, img + map>area
        - sandbox
    * webview
    * 它的跳转记录也会存在于浏览器的前进后退的记录里面
    * code
      ```html
      <p>this is frame 4</p>
      <iframe src="frame3.html" frameborder="1">
        your browser don't support iframe
      </iframe>
      <p>this is frame 4 </p>
      ```
      ```html
      <p>this is frame 3</p>
      <iframe src="frame2.html" frameborder="1"></iframe>
      <p>this is frame 3 </p>
      ```
      ```html
      <p>this is frame 2</p>
      <iframe src="frame1.html" frameborder="1"></iframe>
      <p>this is frame 2 </p>
      ```
      ```html
      <a href="http://mi.com/" target="_top">mi</a>
      ```


* frameset&frame
    - rows/cols="10%,50px,*"
    - noframes
    - code
      ```html
      <frameset rows="100px,*,100px">
        <frame src="https://www.jd.com/">  
        <frameset cols="50,50">
          <frame src="https://www.jd.com/">
          <frame src="https://www.jd.com/">
        </frameset>
        <frame src="https://xieranmaya.github.io/">
      </frameset>
      <noframes>您的浏览器不支持框架</noframes>
      ```

      ```html
      <frameset>
          <frame>
      </frameset>
      <noframes>您的浏览器不支持框架</noframes>

      <canvas>
          <p>no supported</p>
      </canvas>

      <script>
        var a = 8
      </script>
        <noscript>your browser dont support javascript!</noscript>

      <iframe src="" frameborder="0">
           <p>no supported</p>
      </iframe>

      fallback 退化方案
      degrade 降级方案
      backdrop 备用方案

      <script>
          alert()
      </script>
      <noscript>
        <p>woiejflksdjafoiw</p>
      </noscript>
	  
	  
	iframe框架嵌套别的网站，中间的内容是后备内容
	是非自闭标签  <iframe>您的浏览器不支持iframe</iframe>
	progress  进度条
		max  最大值
		
	语义化
	
##5/8
	替换元素和非替换元素

	属性选择器
	[属性 如class]
	[属性的具体值 如 title=“mian”]
	[属性值的结尾部分 如 href$=""]
	[属性值的开头部分 如 href^]
	[属性值的有这个单词*]
	[属性值的有特定的单词~]
	[属性值 |] 值中有单词-开头的
	[     i]  大小写不敏感
	
	h1~p  h1 后面所有兄弟的所有p标签
		
	伪元素 link visitied hover active 顺序  LVHA
	
	位置伪类
	：first-child02
	p：first-child p的内容
	p空格 ：first-child p中子元素的。。。
	
	：last-child
	：nth-first-child
	odd 奇数
	even  偶数
	
	选择器取反
	：not  只能写单一的条件
	
	优先级
	   1                 1           1             1
	内联样式/行内/    id选择器  属性/类/伪选择器  元素/伪元素
	      a              b           c            d
	同级越后面越高
	！important  优先级最高
	继承 
		没有优先级
		
	层叠
		最高 用户important
		依次  网站作者important
				网站作者普通样式
				最终用户
		
	
	质数2，3，5，7，11，13，17.19.23.29.31.37.41.43.47.53.59.61.67.71.73.79.83.89.97
	
	质数  2 3 5
	
##5/9
	first-of-type  第一个元素
	
##5/10
	值
	浏览器默认字号大小16
	
	hsla（色相，饱和度，明度，0-1）
	/A  回车
	
	角度
	de
	
	长度的取值 
	em 百分比 继承都是上次计算的结果
	数字1.5倍  继承的是书写结果
	font-variant
            - normal，默认
            - small-caps
                + 把小写字母显示成小号的大写字母
                + 有些字体专门为小写字母设计了这种样式，而不是单纯的把大写字母显示的小一点。
                    * 当字体没有提供这种样式的时候，浏览器当然就是把大写字母缩小了
            - 与 text-transform：uppercase
                + 这个规则是把所有的文字显示成大写
                * the quick-brown fox
                * captialize -> The Quick-Brown Fox
                子属性
	vertical-align
            * 这个属性适用于【内联元素】
                - img
                - input
                - 替换元素等
                - 而不是给块级元素用的
            * 取值
                - 关键字
                    + baseline
                        * 默认值
                        * 让元素的基线与其父元素行框的基线对齐
                        * 如果一个元素没有基线，如img，input，则让其底部与外面的文字对齐。即使行框没有文字也是一样。是p138-139页
                            - 应用：图片跟文字底部对不齐
                    + sub
                        * 元素的baseline（或底部）会比父该行文字的basline低
                        * 但低多少，标准并没有说。。。
                    + super
                        * 同上，元素的baseline比该行内容的baseline要高
                        * 标准同样没有规定高多少。。
                    + bottom
                        * 目标元素的底部跟这一行的底部对齐
                    + top
                        * 目标元素的顶部跟这一行的顶部对齐
                    + text-top
                    + text-bottom
                        * 元素的顶/底部与文字的顶/底部对齐
                    + middle
                        * 并不是垂直居中
                        * 而是把【元素的中间】与baseline上面0.5ex（即四分之一em）对齐。。。
                    + 百分比
                        * 相对于自己的 line-height
                        * 把其 baseline 向上或向下移动计算出来的值
                    + 固定长度值
                        * 按指定的数值上移或下移元素
                        * 上下移动元素并不会让其与其它行的内容重叠，而是会增加行框的高度
                - 在作用于表格元素时
                    + 只有 baseline，top，middle，bottom 有效，其它无效
                        * 将在表格布局一章说到
						*
--------------------------------------------------
##5/13
 块元素水平布局
 没有auto
	过分受限   重置margin-right为auto
一个auto
	算出
两个auto
	两个margin为auto。计算为相同的值
	其中有一个auto是width，margin的auto为0
三个auto
	两个margin都重置为0
	margin-left为auto时，无法算出负值
	
max-width和min-width和width：auto一起用

	padding-top：61.8%  
	
##5/14
	两个负margin合并，保留大的负值
	多个正负margin合并时   正和正合并  负和负合并  正负相加
	
##5/15
	常规流块元素没有边框和内边距时，包裹着子元素的border-box，父子元素的margin会合并
触发了BFC的元素，无论如何都会包裹着其子元素的margin-box，父子元素的margin也不会合并

	
	定位,position
  定位的是元素的margin-box
  static
    不定位，元素处于常规流中
  fixed
    固定定位
    元素脱离常规流
    相对于视口定位
    视口不动元素就不动，不随滚动条动
  relative
    相对定位
    元素保留常规流中的位置
    相对于自身原来的位置定位
  absolute
    绝对定位
    元素脱离常规流，后续的元素当它不存在
    相对于其最近的定位祖先的padding-box定位
    如果无法找到定位祖先，相对于页面的第一屏定位
  sticky
    综合了static，relative，fixed几种定位方式
    元素即将从视口的某个方向离开时，该方向以fixed定位
    当元素的某一方要离开其包含块时，随其包含块离开
    无论何种情况，元素在常规流中的位置保留
  元素的方位
    top left right bottom
    当不明确指定时，元素的从它在常规流中开始的位置开始。
    以上值为正时，该方向向元素中心方向移动
    即
      top为正为向下移动，为负向上移
      left为正时向右移动，为负时向左移动
      取百分比时，百分比相对于包含块（或定位祖先）的content-box的对应尺寸
  z-index
    元素重叠时，z-index可以调整其堆叠顺序，值越大越往上（离用户越近）
    只能取整数
    当祖先后代都定位时，后代的z-index失效
  常见布局：
    元素明显重叠时，使用定位实现
	
	transition： width 1s      ease  先慢后快
	steps（5 start/end）
	
	
##5/20
行内布局：
  模型：
    行内框在一行以内水平排列，空间不够后就折行
    一行的所有行内框形成行框
    行内框可以通过vertical-align做垂直微调
  行内框的构成：
    匿名文本
      所在属块元素的line-height框
    display: inline
      行内框也是仅通过line-height框确定
      所有额外的padding，border不影响行内框的生成
      对inline元素设置宽高无效
      当inline元素无padding及border时，其底色区域的高度为当前字体line-height为normal时的计算值，与实际设置的line-height无关。
    display: inline-block/table
      行内框为margin-box的外边缘
      基线为最后一行文字的基线/无内容时以m-box下边缘为准
      考虑其自身位置/摆放时，当成图片考虑
      考虑其内容的布局时，当成块/表
  只要行框形成，就要考虑那一行有一个匿名文本
  对于替换元素（图片）
    设置display：inline无效，会当成inline-block；

##5.29

  <meta name="viewport" content="width=device-width">
  
移动端布局：
  viewport标签仅被移动端浏览器支持
    PC端浏览器的渲染窗口即为窗口大小减去额外浏览器自身元素
  如果没有viewport标签，移动端浏览器会主以980像素的浏览器窗口渲染页面（即手机浏览器宽度为980px
  如果有，如果viewport写为width=X，则移动端浏览器就以Xpx为初始包含块渲染页面
  如果写为width=device-width，则移动端浏览器会以出厂设置的宽度为初始包含块的宽度渲染，出厂设置的值一般来说与屏幕物理尺寸正相关，范围一般为320到400左右，目前最主流的是360

  假定视觉稿宽度为X

  对于针对移动端的页面，一般有两种情况：
  1. 页面较复杂，希望页面在不同的手机上效果和比例一致（mi.com移动端）

    页面需要等比缩放，即视觉稿宽度跟浏览器/手机屏幕一样宽
    且我们希望从视觉稿里测量出来的数据能直接用在代码里

    所有用户的设备都支持设定视口宽度的产品来说，直接把视口宽度设置为视觉稿宽度，页面使用px为单位开发，数值直接从视觉稿量出来

    对于并不是所有用户的设备都支持设定视口宽度的产品来说，我们同样希望视觉稿里测量出来的数据可以直接用在代码里，于是要找一个可以灵活缩放的单位（因为不同的手机窗口宽度不一样），让X倍的这个单位正好等于宽屏宽度
      Xrem = 100vw
      rem = (100vw / X)
      html {font-size: calc(100vw / X)}
      有些浏览器不允许最小字号小于12px，而上面的公式算出来的值过小，会被重置，所以将其放大100倍，即
      html {font-size: calc(100vw / X * 100)}
      还有些浏览器不支持calc/vw，所以这个值通过js读取出浏览器视口的宽度并自行算出，然后设置到html元素上

      之后从视觉稿量出来的尺寸将小数点移动两位后加rem单位即可用在代码里。

  2. 页面较简单，希望页面在更大的手机上显示更多的内容（github移动端）
    直接使用device-width且使用px以及流式布局（块元素自动占满宽度）

  3. 对于杂合形页面，即布局复杂，又有很多文字
    布局使用rem，文字使用px，width=device-width

## 6.26
   
   访问外层作用域都没有的变量，会创建出来并变成全局变量
   var 声明的变量，会声明提前 hiost
   
   闭包：能够引用一个处于一个函数内部的特定变量的行为
   函数每次运行都会创建一个作用域
   生命周期  从创建到销毁
   函数本身处在哪个作用域（A），它运行时创建的作用域（B）就在哪个作用域（   A）内部
   函数本身也是处于一个作用域的。是创建它的函数运行时所创建的作用域。
   
   数组
   值的有序集合
    .unshift   从前面增加
    .shift 第一个
    .push 从后面增加
    .pop 数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。
    .forEach 遍历数组
    indexOf()  在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。
    .splice() 从哪一位开始删掉多少，
    .length

    数组中套数组  二维数组

## 6.27
    101..toString()  转换二进制


    调用栈的深度是展开的层次
    .split  变成数组
    Number（） 变成数字

## 6.28
    输入n个数并倒序输出
    n = 1输入一个数并输出
    n > 1输入一个数x （输入n-1个数并倒序输出）

    function input (n) {
        if n == 1 {
            return n
        } else (n > 1) {

        }
    }

    charCodeAt（）asiic码
    foobar  slice（1，5） “ooba”

## 7.1
    document.write() 向文档的解析流写入内容，文档一旦解析完成<html>,解析就会关闭，重新write会导致重新打开一个解析流，之前的内容会被完全覆盖掉

    document.open() 打开解析流
    document.open() 关闭解析流

    parseInt(1101" ,5)  五进制理解

    js中所有位运算只有整数才能参与
    浮点数参与时，保留整数参与
    js中浮点数的范围远高于32位整数的范围
    运算结果以有符号32位整数的范围
    除了>>>运算符，他的运算结果以无符号理解

    曼哈顿距离

    最后开始的括号如果还没闭合的话，之前开始的括号就不能闭合。
    如果任何一个括号内部的括号没有闭合，它自己就不能闭合。

## 7.2
    方法 method  指向函数的属性一把叫做方法


## 7.3
    .slice() 浅复制
    .concat() 拼接

    var ary = Array(9)   创建长度为9的空数组
    .fill()  填充
    .flat()  将元素和遍历到的子数组的元素返回新数组


    function flat(ary) {
        var sum = []
        for ()
    }

    Array.isArray  判断是不是数组

    function includes(ary,value) {
        for (var i = 0;i < ary.lrngth;i++) {
            if (ary[i] === value) {
                return true
            }
        }
    }

    return ary.indexOf(value) >= 0

    包装对象：一个真实的对象包装了一个原始类型
    永远不使用包装类型

    trim  用于字符串删除空白符号

    str.anchor() 包进a标签

    arguments 对象
    function sum() {
        var result = 0
        for (var i = 0;i < arguments.length;i++) {
            
            result += sum[i]
        }
    }

    var ary = Array,form()  类似数组返回真数组

    剩余参数
    function

    参数的默认值
    function slice(ary,start = 0,end = ary.length) {

    }

    Math.max(1,2,3,4,5)

    var ary = [3,4,5,6,7]

    Math.max

    trim  删除空白字符

    Math.random  伪随机数

## 7.4
    var data = [
        [2],
        [1,4],
        [6,5,3,1],
        [6,5,8,1,7]
    ]

    function maxCollect(row,col) {
        if ()
    }



## 7.5
    function arrarToList(ary) {
        var nodes = []
        for (var i = 0;i < ary.length; i++) {
            var node = {
                value: ary[i],
                next: null
            }
            nodes.push(node)
        }
        for (var i = 0;i < nodes.length - 1;i++) {
            nodes[i].next = nodes{i + 1}
        }
        return nodes[0]
    }

    function arrarToList2(ary) {
        var dummy = {
            value: undefined,
            next: null,
        }
        var prey = dummy
        for (var i = 0;i < ary.length; i++) {
            var node = {
                value: ary[i],
                next: null
            }
            prev.next = node
            prev = node
        }
        return dummy.next
    }

    function arrarToList3(ary) {
        if (ary.length == 0) {
            return null
        }
        var head = ary[0]
        var aryTail = ary.slice(1)
        var headNode = {
            value: head
            next: null
    }

        var tail = arrarToList3(aryTail)
        headNode.next = tail
        return heasNode

    }

    function arrarToList3(ary,start = 0) {
        if (start == ary.length) {
            return null
        }
        var head = ary[start]
        var aryTail = ary.slice(1)
        var headNode = {
            value: head
            next: null
    }

        var tail = arrarToList3(aryTail)
        headNode.next = tail
        return heasNode

    }


    function listToArray(list) {
        var result = []
        while (list != null) {
            result.push(list.value)
            list = list.next
        }
    }

    function listToArray(list) {
        if (list == null) {
            return []
        }
        var tail = list.next
        return [list.value].concat(listToArray(tail))
        return [list.value], ...(listToArray(tail))
    }
 
    function size(list) {
        var c = 0
        while (list != null) {
            c++
            list = list.next
        }
        return c
    }

    function size2(list) {
        if(!list) {
            return 0
        }
        return 1 + size2(list.next)
    }



    function insert(list,index,value) {
        if (!list) {
            return {
                value: value,next: null
            }
        }
        if (index == 0) {
            return {
                value: value,
                next: list
            }
        }
        var head = list
        var idx = -1
        while (list) {
            idx++
            if (idx == index - 1) {
                break
            }
            list = list.next
        }
        var node = {
            value: value,
            next：null,
        }
        var tmp = list.next
        list.next = node
        node.next = tmp

    }

    function nth(list,index) {
        if (!list) {
            return undefined
        }
        if (index == 0) {
            return list.value
        }
    return nth(list.next,index - 1)
    }

    function prepend(list,value) {
        return insert(list,0,value)
    }

    function append(list,value) {
        return insert
    }






    线性同余
    平方取中法

## 7.9
    ary.forEach((val.idx,ary) => {

    })




    fun.apply(null,[1,2,3])
    fun.length //形参个数
    fun.toString()// 函数的源代码
    fun.name //函数的名字

    JSON
    JSON.parse
    双引号的内部不能出现tab符，不能出现多余的符号,没有undf

    function filter(ary，test) {

    }

    function map(ary，mapper) {
        
    }

    不使用高阶函数，实现计算19世纪女性平均年龄的代码

    var ancestry = 


    实现一个函数d，其接收一个函数，返回其导函数，即fp=d（f），fp为f的导函数。

    function d(f) {
        
    }

## 7.10
    function reduce(ary,ini)

    function max () {

    }


## 7.11
```javascript
    reduce
    [1,2,3,4,5].reduce(function(memo, item, index, ary) {
  if (index !== ary.length - 1) {
    return memo + item
  } else {
    return (memo + item) / ary.length
  }
})

[1,2,3,4,5].reduce(function(memo, item, index) {
  return (memo * index + item) / (index + 1)
})



ancestry
  .filter(man)
  .filter(is19s)
  .map(age)
  .reduce(average)



function map(ary, mapper) {
  return ary.reduce(function(result, item) {
    result.push(mapper(item))
    return result
  }, [])
}

function keyBy(ary, key) {
  var result = {}
  ary.forEach(item => {
    reslut[item[key]] = item
  })
  return result
}


function keyBy(ary, key) {
  ary.reduce((result, item) => {
    result[item[key]] = item
    return result
  }, {})
}

//根节点在数组中的位置的一个由数组表达的二叉树
//转换为一颗由二叉链表表达的树
//递归
    function ary2tree(ary,rootpos = 0) {
        if (rootpos >= ary.length || ary[rootpos] == null) {
            return null
        }
        var left = ary2tree(ary,rootpos * 2 + 1)
        var right = ary2tree(ary,rootpos * 2 + 1)

        var root = {
            val: ary[rootpos],
            left: left,
            right: right,
        }
        
        return root
    }

//由二叉链表表达的树转回数组
//递归
    function tree2ary(root,pos = 0,ary = []) {
        if (root) {
            ary[pos] = root.val
            tree2ary(root.left,pos * 2 + 1,ary)
            tree2ary(root.right,pos * 2 + 2,ary)
        }
        return ary
    }
    tree2ary(root)



    function lcary2tree(root) {
        if (ary.length == 0) {
            return null
        }
        var root = {
            val: ary[0],
            left: null,right: null,
        }

        var nodes = [root]

        for (var i = 1;i < ary.length;i++) {
            var curr = nodes.shift()

            if (ary[i] != null) {
                var node = {
                val: ary[i],
                left: null,right: null,
               }
            curr.left = node
            nodes.push(node)
            }else {
                curr.left = null
            }
            
            i++
            if (!(i < ary.length)) {
                break
            }

            if (ary[i] != null) {
                var node = {
                val: ary[i],
                left: null,right: null,
               }
            curr.right = node
            nodes.push(node)
            }else {
                curr.right = null
            }


        }

        function lctree2ary(root) {
            if (root) {
                var resule = []
                var nodes = [root]
                while (nodes.length) {
                    var curr = nodes.shift()
                    if (curr) {
                        resule.push(curr.val)
                        nodes.push(resule.left,resule.right)
                    }else {
                        result.push(null)
                    } 
                }
                return result
            }
            return []
        }

    function lctree2ary2(root) {
        if (root) {
            var resule = [root.val]
            var nodes = [root]
            while(nodes.length) {
                var curr = nodes.shift()
                if (curr.left) {
                    result.push(curr.left.val)
                    nodes.push(curr.left)
                }else {
                    result.push(null)
                }

                if (curr.right) {
                    result.push(curr.right.val)
                    nodes.push(curr.right)
                } else {
                    result.push(null)
                }
            }
            while (resule[result.length - 1] === null) {
                result.pop()
            }
            return resule
        }
        return []
    }
```





## 7.12

```javascript
    function inOrderTraverse(root,action) {
        if (root) {
            inOrderTraverse(root.left,action)
            action(root.val)
            inOrderTraverse(root.right,action)
        }
    }

    function preOrderTraverse(root) {
        if (root) {
            console.log(root.val)
            preOrderTraverse(root.left)
            preOrderTraverse(root.right)
        }
    }

    function postOrderTraverse(root) {
        if (root) {
            postOrderTraverse(root.left)
            postOrderTraverse(root.right)
            console.log(root.val)
        }
    }

    前序：中。左。右
    中序：左，中，右
    后序：左，右，中

    排序二叉树

    //加入节点
    function insertIntoBST(root,val) {
        if (!root) {
            return new TreeNode(val)
        }
        if (val < root.val) {
            root.left = insertIntoBST(root.left,val)
        }else {
            root.right = insertIntoBST(root.right,val)
        }
        return root
    }

    //bst
    function bstSort(ary) {
        var root = null
        for (var i = 0;i < ary.length;i++) {
            root = insertIntoBST(root,ary[i])
        }
        k = 0
        inOrderTraverse(root ,val => {
            ary[k++] = val
        })
    return ary
    }

    //选择排序
    function swap(ary,i,j) {
        if (i != j) {
            var t = ary[i]
            ary[i] = ary[j]
            ary[j] = t
        }
        return ary
    }
    
    function selectSort(ary) {
        for(var pos = 0;pos <= ary.length - 2;pos++) {
            var minpos = pos
            for(var i = pos + 1;i < ary.length;i++) {
                if (ary[i] < ary [minpos]) {
                    minpos = i
                }
            }
            swap(ary,pos,minpos)
        }
        return ary
    }

//插入排序

平衡树
红黑树
AVL树

//删除节点
```

## 7.15
    Object.keys
    Object.values
```javascript
//归并
    function mergeSort(ary) {
        if (ary.length < 2) {
            return ary.slice()
        }
        var miad = ary.length >> 1
        var left = ary.slice(0,mid)
        var right = ary.slice(mid)

        left = mergeSort(left)
        right = mergeSort(right)

        var result = []
        var i = 0,j = 0

        while(i < left.length && j < right.length ) {
            if (left[i] < right[j]>) {

            }
        }
    }

//快排
    function quickSort2(ary) {
        if (ary.length < 2) {
            return ary.slice()
        }
        var randomIndex = Math.floor(Math.random() * ary.length)
        var randomValue = ary[randomIndex]

        var left = []
        var middle = []
        var right = []

        for(var item of ary) {
            if (item < randomValue) {
                left.push(item)
            }else if (item > randomValue) {
                right.push(item)
            }else {
                middle.push(item)
            }
        }
        left = quickSort2(left)
        right = quickSort2(right)

        return [...left,...middle,...right]

    }


    //就地排序
    对于所有元素都相同的数组来说，性能会退化为n*n，调用栈也会达到n
    层
    function quickSort(ary,start = 0,end = ary.length - 1) {
        if (end - start <= 0) {
            return ary
        }
        var pivotIndex = Math.floor(Math.random() * (end - start + 1) + start)
        var pivot = ary[pivotIndex]

        swap(ary,pivotIndex,end)

        var i = start - 1
        for (var j = start;j < end;j++) {
            if (ary[j] < pivot) {
                i++
                swap(ary,i,j)
            }
        }
        i++
        swap(ary,i,end)

        quickSort(ary,start,i - 1)
        quickSort(ary,i + 1,end)

        return ary

    }


```
     排序前后不改变相同元素的相对位置，则称为稳定的排序算法
    反之，则为不稳定的
    不稳定的排序算法：
   选择排序，就地快排
    稳定的排序算法：冒泡，归并，插入排序，bst排序


********************-/## 7.16

    includes 可以判断NaN,indexof不行

    bind

```javascript
    function bind(f,arg1,arg2,arg3) {
        return function() {

        }
    }

    negate 反函数

    function flip(func) {
        return function(...arys) {
            return func(...args.reverse())
        }
    }


    function flatten(ary) {
        var result = []
        for(var item of ary) {
            if (Array.isArray(item)) {
                for(var val of item) {
                    result.push(val)
                }
            } else {
                result.push(item)
            }
        }
        return result
    }

    function flattenDeep(ary) {
        var result = []
        for(var item of ary) {
            if (Array.isArray(item)) {
                var flattedItem = flattenDeep(item)
                result.push(...flattedItem)
            } else {
                result.push(item)
            }
        }
        return result
    }

    function flattenDepth(ary,depth = 1) {
        if (depth == 0) {
            return ary.slice()
        }
        var result = []
        for(var item of ary) {
            if (Array.isArray(item)) {
                var flattedItem = flattenDepth(item,depth - 1)
                result.push(...flattedItem)
            } else {
                result.push(item)
            }
        }
        return result
    }


    function before(n,func) {
        var times = 0
        var lastResult
        return function(...args) {
            times++
            if (times < n) {
                return lastResult = func(...args)
            }else{
                return lastResult
            }
        }
    }

    function after(n,func) {
        var times = 0
        return function(...args) {
            times++
            if (times < n) {
                return 
            }else{
                return func(...args)
            }
        }
    }

    function ary(f, n = f.length) {
        return function (...args) {
            return f(args.slice(0,n))
        }
    }






    
```

